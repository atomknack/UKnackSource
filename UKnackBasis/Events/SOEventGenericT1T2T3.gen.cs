//----------------------------------------------------------------------------------------
// <auto-generated> This code was generated from EventScriptableObject
// Changes will be lost if the code is regenerated.</auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
#if UNITY_EDITOR
using UnityEditor;
using System.Diagnostics;
#endif
using UnityEngine;
using UnityEngine.Events;
using UKnack.Common;

namespace UKnack.Events;

public abstract class SOEvent<T1,T2,T3> : ScriptableObjectWithReadOnlyName, IEvent<T1,T2,T3>
{
    [NonSerialized] internal readonly List<UnityEvent<T1,T2,T3>> subscribedByUnityEvent = new List<UnityEvent<T1,T2,T3>>();
    [NonSerialized] internal readonly List<Action<T1,T2,T3>> subscribedByCSEvent = new List<Action<T1,T2,T3>>();
    [NonSerialized] internal readonly List<ISubscriberToEvent<T1,T2,T3>> subscribedByISubscriberToEvent = new List<ISubscriberToEvent<T1,T2,T3>>();
#if UNITY_EDITOR
    [NonSerialized] protected readonly Dictionary<object,string> debugSubscriberDescription = new Dictionary<object,string>();
#endif
    
    [NonSerialized] private string _savedName;

    /// <summary>
    /// Subscribes reciever of event
    /// </summary>
    /// <param name="subscriber">To unsubscribe use UnsubscribeNullSafe extension method.
    /// subscriber will be called when something is published to event</param>
    public virtual void Subscribe(Action<T1,T2,T3> subscriber) 
    {
        if (subscriber == null)
            throw new ArgumentNullException(nameof(subscriber));
        subscribedByCSEvent.Add(subscriber);
#if UNITY_EDITOR
var method= new StackFrame(1).GetMethod();
        debugSubscriberDescription[subscriber] = $"method: {method.Name}, declared by: {method.DeclaringType}";
#endif
    }
    internal virtual void Unsubscribe(Action<T1,T2,T3> subscriber)
    {
#if UNITY_EDITOR
if (subscriber == null)
    throw new ArgumentNullException(nameof(subscriber));
int subscriberCount = subscribedByCSEvent.Count(x=>x==subscriber);
if ( subscriberCount!= 1)
    throw new ArgumentException($"{nameof(subscriber)} has not 1, but {subscriberCount} references in Event {this.name}, fulldescription: {debugSubscriberDescription[subscriber]}");    
debugSubscriberDescription.Remove(subscriber);
#endif
            
        bool removed = subscribedByCSEvent.Remove(subscriber);

#if UNITY_EDITOR
if (removed == false)
    throw new ArgumentException($"could not remove {nameof(subscriber)}"); 
#endif
    }
    void IEvent<T1,T2,T3>.Unsubscribe(Action<T1,T2,T3> subscriber) => 
        Unsubscribe(subscriber);

    internal virtual bool IsOneOfSubscribers(Action<T1,T2,T3> subscriber)
    {
        if (subscriber == null)
            throw new ArgumentNullException(nameof(subscriber));

        return subscribedByCSEvent.Contains(subscriber);
    }

    /// <summary>
    /// Subscribes reciever of event
    /// </summary>
    /// <param name="subscriber">To unsubscribe use UnsubscribeNullSafe extension method.
    /// subscriber will be called when something is published to event</param>
    public virtual void Subscribe(UnityEvent<T1,T2,T3> subscriber) 
    {
        if (subscriber == null)
            throw new ArgumentNullException(nameof(subscriber));
        subscribedByUnityEvent.Add(subscriber);
#if UNITY_EDITOR
var method= new StackFrame(1).GetMethod();
        debugSubscriberDescription[subscriber] = $"method: {method.Name}, declared by: {method.DeclaringType}";
#endif
    }
    internal virtual void Unsubscribe(UnityEvent<T1,T2,T3> subscriber)
    {
#if UNITY_EDITOR
if (subscriber == null)
    throw new ArgumentNullException(nameof(subscriber));
int subscriberCount = subscribedByUnityEvent.Count(x=>x==subscriber);
if ( subscriberCount!= 1)
    throw new ArgumentException($"{nameof(subscriber)} has not 1, but {subscriberCount} references in Event {this.name}, fulldescription: {debugSubscriberDescription[subscriber]}");    
debugSubscriberDescription.Remove(subscriber);
#endif
            
        bool removed = subscribedByUnityEvent.Remove(subscriber);

#if UNITY_EDITOR
if (removed == false)
    throw new ArgumentException($"could not remove {nameof(subscriber)}"); 
#endif
    }
    void IEvent<T1,T2,T3>.Unsubscribe(UnityEvent<T1,T2,T3> subscriber) => 
        Unsubscribe(subscriber);

    internal virtual bool IsOneOfSubscribers(UnityEvent<T1,T2,T3> subscriber)
    {
        if (subscriber == null)
            throw new ArgumentNullException(nameof(subscriber));

        return subscribedByUnityEvent.Contains(subscriber);
    }

    /// <summary>
    /// Subscribes reciever of event
    /// </summary>
    /// <param name="subscriber">To unsubscribe use UnsubscribeNullSafe extension method.
    /// subscriber will be called when something is published to event</param>
    public virtual void Subscribe(ISubscriberToEvent<T1,T2,T3> subscriber) 
    {
        if (subscriber == null)
            throw new ArgumentNullException(nameof(subscriber));
        subscribedByISubscriberToEvent.Add(subscriber);
#if UNITY_EDITOR
var method= new StackFrame(1).GetMethod();
        debugSubscriberDescription[subscriber] = $"method: {method.Name}, declared by: {method.DeclaringType}";
#endif
    }
    internal virtual void Unsubscribe(ISubscriberToEvent<T1,T2,T3> subscriber)
    {
#if UNITY_EDITOR
if (subscriber == null)
    throw new ArgumentNullException(nameof(subscriber));
int subscriberCount = subscribedByISubscriberToEvent.Count(x=>x==subscriber);
if ( subscriberCount!= 1)
    throw new ArgumentException($"{nameof(subscriber)} has not 1, but {subscriberCount} references in Event {this.name}, fulldescription: {debugSubscriberDescription[subscriber]}");    
debugSubscriberDescription.Remove(subscriber);
#endif
            
        bool removed = subscribedByISubscriberToEvent.Remove(subscriber);

#if UNITY_EDITOR
if (removed == false)
    throw new ArgumentException($"could not remove {nameof(subscriber)}"); 
#endif
    }
    void IEvent<T1,T2,T3>.Unsubscribe(ISubscriberToEvent<T1,T2,T3> subscriber) => 
        Unsubscribe(subscriber);

    internal virtual bool IsOneOfSubscribers(ISubscriberToEvent<T1,T2,T3> subscriber)
    {
        if (subscriber == null)
            throw new ArgumentNullException(nameof(subscriber));

        return subscribedByISubscriberToEvent.Contains(subscriber);
    }

    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal virtual void InternalInvoke(T1 t1,T2 t2,T3 t3)
    {
        InvokeSubscribers(this, t1,t2,t3);
    }

    internal static void InvokeSubscribers(SOEvent<T1,T2,T3> soe, T1 t1,T2 t2,T3 t3)
    {
        if (soe==null)
            throw new ArgumentNullException(nameof(soe));
        //internalEvent.Publish(t1,t2,t3);

        for (int i = 0; i<soe.subscribedByCSEvent.Count; ++i)
        {
            soe.subscribedByCSEvent[i]?.Invoke(t1,t2,t3);
        }
        for (int i = 0; i<soe.subscribedByUnityEvent.Count; ++i)
        {
            soe.subscribedByUnityEvent[i]?.Invoke(t1,t2,t3);
        }
        for (int i = 0; i<soe.subscribedByISubscriberToEvent.Count; ++i)
        {
            if(soe.subscribedByISubscriberToEvent[i]!=null)
                soe.subscribedByISubscriberToEvent[i].OnEventNotification(t1,t2,t3);
        }
    }

protected virtual void Init()
{
    _savedName = name;
    //var countOnInitStart = CheckCount();
    //if (countOnInitStart>0)
    //    UnityEngineDebug.Log($"SOEvent {name} have {countOnInitStart} subscribers at init start");
    //subscribedByCSEvent.Clear();
}

protected virtual void Cleanup()
{
}

    protected void OnEnable()
    {
    Init();
#if UNITY_EDITOR
        EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
#endif
    }
    protected void OnDisable()
    {
    Cleanup();
#if UNITY_EDITOR
        EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
#endif
    }

#if UNITY_EDITOR
    private void OnPlayModeStateChanged(PlayModeStateChange state)
    {
        if (state != PlayModeStateChange.ExitingPlayMode) 
            return;
        //Debug.Log($"CSEvents:{subscribedByCSEvent.Count}, UnityEvents:{subscribedByUnityEvent.Count}");
        
        Cleanup();
        CommonStatic.DoActionLater(500, () => 
            { 
                //UnityEngine.Debug.Log("Checking count after wait"); 
                DebugCheckCount(); 
            });
    }
#endif
    protected virtual int SubscribersCount() => subscribedByCSEvent.Count + subscribedByUnityEvent.Count + subscribedByISubscriberToEvent.Count;

    private int DebugCheckCount()
    {
    //Debug.Log($"CheckCount");
    int result = SubscribersCount();
        if (result>0)
        {
            UnityEngine.Debug.LogError(
$"CheckCount for {_savedName} NOT ZERO: CSEvents:{subscribedByCSEvent.Count}, UnityEvents:{subscribedByUnityEvent.Count}, ISubscriberToEvent:{subscribedByISubscriberToEvent.Count}");

#if UNITY_EDITOR
            foreach (var sub in subscribedByCSEvent)
                UnityEngine.Debug.Log($"csEvent subscribed by ({debugSubscriberDescription[sub]}) not unsubscribed, check (un)subscriber object");

            foreach (var sub in subscribedByUnityEvent)
                UnityEngine.Debug.Log($"unityEvent subscribed by ({debugSubscriberDescription[sub]}) not unsubscribed, check (un)subscriber object");

            foreach (var sub in subscribedByISubscriberToEvent)
                UnityEngine.Debug.Log($"ISubscriberToEvent subscribed by ({sub.Description} from {debugSubscriberDescription[sub]}) not unsubscribed, check (un)subscriber object");
#endif
        }
    return result;
    }

}

